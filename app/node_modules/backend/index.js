const dialog = require("electron").remote.dialog;
const fs = require('fs');

global.deck = []; //the deck collection (right hand pane)
global.collection = {}; //all the possible cards sorted into [Monsters, Spells, Traps]
global.cardCollection = null;// = document.getElementById("CardCollection"); //the collection of cards in the center pane
global.ft = null;// = document.getElementById("CardFilter"); //the filter, right-most textbox

var IndexJson; //the global card index file
var extras = ["Xyz", "Fusion", "Synchro", "Pendulum"]; //types that are meant to be in the extra deck

//Saves the deck to a file
function SaveDeck() {
    var deckName = document.getElementById("DeckName").value;

    var extraDeck = SortDeck(deck.filter(o => o.json["subCategories"].contains(extras))); //gets the extra Deck cards
    var mainDeck = SortDeck(deck.filter(o => !extraDeck.includes(o))); //gets the main deck cards


    var deckString = "";
    deckString += "#Created By [Yu-Gi-Oh Deck Builder]\n";

    //----------------------------------------
    deckString += "#main\n";
    for (var i = 0; i < mainDeck.length; i++) {
        var item = mainDeck[i];
        for (var j = 0; j < item.amount; j++) {
            deckString += `${item.json.cardNumber}\n`;
        }
    }
    //----------------------------------------
    //| iterates through all the mainDeck cards
    //| and adds them to the string
    //----------------------------------------

    //----------------------------------------
    deckString += "#extra\n";
    for (var i = 0; i < extraDeck.length; i++) {
        var item = extraDeck[i];
        for (var j = 0; j < item.amount; j++) {
            deckString += `${item.json.cardNumber}\n`
        }
    }
    //----------------------------------------
    //| iterates through all the extraDeck cards
    //| and adds them to the string
    //----------------------------------------

    deckString += "!side\n"; //haven't implemented side deck

    //allows for saving of the deckstring to a file
    dialog.showSaveDialog(
        {
            title: `Saving Deck '${deckName != "" ? deckName : "DECK"}'`,
            defaultPath: `*/${deckName != "" ? deckName : "DECK"}.ydk`,
            filters: [
                {name: "YGOPro Deck", extensions: ["ydk"]}
            ]
        }, function (fileName) {

            if (fileName === undefined) return;

            fs.writeFile(fileName, deckString, function (err) {
                if (err == undefined)
                    dialog.showMessageBox({title: `Deck saved to ${fileName}`, message: deckString, buttons: ["OK"]});
                else
                    dialog.showErrorBox("File Save Error", err.message);
            });

        });
}

//Loads the deck from a file
function LoadDeck() {
    //empties the deck
    if (deck.length > 0) {
        var replaceDeck = dialog.showMessageBox({
            type: 'question',
            buttons: ['Yes', 'No'],
            title: 'Confirm',
            message: 'Deck will be overridden.\nAre you sure you want to load a deck?'
        }) === 0;
        if (!replaceDeck)
            return;
        deck = [];
        //clears the deck pane
        frontend.UpdateShownDeck();
    }

    //prompts the user to open a deck file
    dialog.showOpenDialog(
        {
            title: `Loading Deck`,
            defaultPath: `*/${"DECK"}.ydk`,
            filters: [
                {name: "YGOPro Deck", extensions: ["ydk"]}
            ]
        }, function (fileNames) {
            if (fileNames == undefined)
                return;
            var fileName = fileNames[0];
            fs.readFile(fileName, 'utf-8', function (err, data) {

                //gets all the passcodes as an array
                var numbers = data.split("\n").filter(o => !o.startsWith("#") && !o.startsWith("!") && o != "");

                for (var i = 0; i < numbers.length; i++) {

                    //gets the indexed card json from IndexJson
                    var jsonI = IndexJson.find(o => parseInt(o.cardNumber) == parseInt(numbers[i]));

                    //gets the card from the collection
                    var tempCard = GetCard(jsonI.cardType, parseInt(numbers[i]));

                    //adds the card to the deck
                    var paramObj = new objects.ParamObject();
                    paramObj.jsonLocation = tempCard.jsonLocation;
                    paramObj.args = [1];

                    LoadJsonFile(AddCard, paramObj);
                }

                //updates the deck pane to display all cards
                frontend.UpdateShownDeck();
            });
        });
}

//Loads the Card Index
function LoadIndexFile(action, paramObj) { //action is the callback
    fs.readFile(`${__approot}/Cards/index.json`, async function read(err, data) { //reads the card index
        if (err) {
            throw err;
        }

        var json = await JSON.parse(data);

        if (paramObj !== undefined)
            switch (paramObj.args.length) {
                case 1:
                    action(json, paramObj.args[0]);
                    break;
                case 2:
                    action(json, paramObj.args[0], paramObj.args[1]);
                    break;
                case 3:
                    action(json, paramObj.args[0], paramObj.args[1], paramObj.args[2]);
                    break;
                default:
                    action(json);
                    break;
            }
        else
            action(json);
    });
}

//loads any JsonFile
function LoadJsonFile(action, paramObj) {
    var jsonLocation = paramObj.jsonLocation != "" ? paramObj.jsonLocation : `${__approot}/Cards/Json/${paramObj.number}.json`;
    fs.readFile(jsonLocation, async function read(err, data) {
        if (err) {
            throw err;
        }

        var json = await JSON.parse(data); //gets the json data

        if (paramObj.correctSubCats) //if there is a param, attempt to correct the subCategories array from a string to an actual array
            json["subCategories"] = JSON.parse(json["subCategories"]);

        if (paramObj !== undefined)
            switch (paramObj.args.length) {
                case 1:
                    action(json, paramObj.args[0]);
                    break;
                case 2:
                    action(json, paramObj.args[0], paramObj.args[1]);
                    break;
                case 3:
                    action(json, paramObj.args[0], paramObj.args[1], paramObj.args[2]);
                    break;
                default:
                    action(json);
                    break;
            }
        else
            action(json);
    });
}

//initializes the global collection object
function InitializeCardCollection(indexJson) {
    IndexJson = indexJson; //initializes the global cardIndex object
    collection.name = "CardIndex";
    var monsters = {};
    monsters.cards = [];
    var spells = {};
    spells.cards = [];
    var traps = {};
    traps.cards = [];
    collection.categories = [monsters, spells, traps];

    for (var i = 0; i < Object.keys(indexJson).length; i++) { //for each card in the index
        //----------------------------------------
        var span = document.createElement("span");
        span.classList.add("nav-group-item");
        span.id = `card-${Object.values(indexJson)[i]["cardNumber"]}`;
        span.value = Object.values(indexJson)[i];
        span.cardType = Object.values(indexJson)[i]["cardType"];
        span.name = Object.values(indexJson)[i]["name"];
        span.number = Object.values(indexJson)[i]["cardNumber"];
        span.type = "span";
        span.jsonLocation = `${__approot}/Cards/Json/${Object.values(indexJson)[i]["cardNumber"]}.json`;
        //----------------------------------------
        //| Creates a span containing all the
        //|  values of the card
        //----------------------------------------

        //----------------------------------------
        var image = document.createElement("img");
        image.classList.add("icon");
        image.style.marginTop = "1px";
        image.style.width = "20px";
        image.style.height = "20px";
        switch (Object.values(indexJson)[i]["cardType"]) {
            case 1:
                image.src = "images/Monster/level_star.png";
                break;
            case 2:
                image.src = "images/Spell/spell.png";
                break;
            case 3:
                image.src = "images/Trap/trap.png";
                break;
            default:
                break;
        }
        //----------------------------------------
        //| Creates the accompanying icon to be
        //|  displayed next to the card name
        //----------------------------------------

        //attaches the image to the span
        span.appendChild(image);

        //adds the name of the card to the span
        span.appendChild(document.createTextNode(Object.values(indexJson)[i]["name"]));

        span.onclick = e => eventcollection.Span_Clicked_Collection(e.currentTarget);

        span.ondblclick = e => eventcollection.Span_DblClicked_Collection(e.currentTarget);

        //collection is [monster, spell, trap] to match the cardType values
        collection.categories[parseInt(Object.values(indexJson)[i]["cardType"]) - 1].cards.push(span);
    }
    //updates what can be seen by the user
    frontend.UpdateShownCollection();
    //updates the card shown on the right to be the top most card
    frontend.UpdateShownCard(cardCollection.childNodes[0]);
}

//returns the card with the corresponding details
function GetCard(cardType, number) {
    return collection.categories[cardType - 1].cards.find(o => o.number == number);
}

//adds a card to the deck
function AddCard(json, amount) {
    //attempts to find the card within the deck
    var item = deck.find(o => o.number == json["cardNumber"]);
    //if the card can't be found
    if (item == null) {
        //----------------------------------------
        item = objects.CreateCard(json, amount);
        deck.push(item);
        //----------------------------------------
        //| Creates a card object and pushes it
        //|  to the deck array
        //----------------------------------------
    } else {
        //if there's already 3 in the deck, don't add any
        if (item.amount >= 3) return;
        //else increment the value by the given amount
        item.amount += amount;
    }

    eventcollection.Card_Added(item);
}

//removes a card from the deck
function RemoveCard(json, amount) {
    //attempts to find the card in the deck
    var item = deck.find(o => o.number == json["cardNumber"]);
    //if the card is in the deck
    if (item != null) {
        //decrease the amount of cards in the deck by amount
        item.amount -= amount;
        //if the amount of cards <= 0 then remove it
        if (item.amount <= 0) {
            deck = deck.filter(o => o !== item);
        }
        eventcollection.Card_Removed(item);
    }
}

//sorts the deck by cardType and then by name
function SortDeck(d) {
    if (d == undefined)
        d = deck;
    var x = d.filter(o => o.type == 1);
    var y = d.filter(o => o.type == 2);
    var z = d.filter(o => o.type == 3);

    x.sort((a, b) => a.name.localeCompare(b.name));
    y.sort((a, b) => a.name.localeCompare(b.name));
    z.sort((a, b) => a.name.localeCompare(b.name));

    return (x.concat(y).concat(z));
}

function Start() {
    LoadIndexFile(InitializeCardCollection); //loads the card index triggering <InitializeCardCollection> as a callback
}

module.exports = {
    SaveDeck,
    LoadDeck,
    Start,
    SortDeck,
    AddCard,
    RemoveCard,
    LoadJsonFile
};